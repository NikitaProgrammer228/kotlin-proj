package com.accelerometer.app.measurement

object MeasurementConfig {
    const val MEASUREMENT_DURATION_SEC = 10.0
    const val CHART_AXIS_RANGE_MM = 50.0  // Диапазон графика в мм (±50)

    const val ENABLE_DEBUG_LOGS = true

    // Частота опроса датчика (MicroSwing использует 50 Гц)
    const val EXPECTED_SAMPLE_RATE_HZ = 50.0
    
    // Калибровка — время для определения базового положения И прогрева high-pass фильтра
    // 3 сек = 150 сэмплов при 50 Гц — достаточно для полной стабилизации фильтра
    const val MOTION_CALIBRATION_DURATION_SEC = 3.0
    
    // High-pass filter alpha: ещё чуть ниже, чтобы приглушить мелкие пики и снизить подсчёт частоты
    const val HIGH_PASS_ALPHA = 0.86
    
    // Коэффициенты: градусы → миллиметры (по осям отдельно)
    // Масштабирование под амплитуды немецкого ПО
    const val ANGLE_TO_MM_SCALE_X = 4.3
    const val ANGLE_TO_MM_SCALE_Y = 4.3

    // Дополнительный визуальный множитель только для мишени (target graph),
    // чтобы траектория «доставала» до красной зоны как в немецком ПО,
    // не влияя на физику данных и график времени.
    const val TARGET_GRAPH_SCALE = 1.18f

    // Управление калибровкой/стабилизацией.
    // Если выключить, график и метрики стартуют сразу, без прогрева.
    const val ENABLE_CALIBRATION = false
    // Длительность стабилизации high-pass после калибровки (сек).
    // При 0.0 стабилизация выключена.
    const val STABILIZATION_DURATION_SEC = 0.0

    // Инверсия осей (1.0 = как есть, -1.0 = переворот знака)
    // По наблюдению: наклон «от себя» идёт вверх у нас и вниз у немцев — инвертируем Y
    const val AXIS_INVERT_X = 1.0   // X оставляем
    const val AXIS_INVERT_Y = -1.0  // Y переворачиваем, чтобы совпасть с немецким ПО
    
    // Максимальное смещение в мм — возвращаем к рабочим ±40
    const val MOTION_POSITION_LIMIT_MM = 40.0

    // Параметры для расчёта метрик
    // Частота: высокий порог — считаем только крупные пики, не мелкую дрожь
    const val AMPLITUDE_THRESHOLD_MM_FREQ = 3.0    // для частоты
    // Координация: порог для детекции амплитуд (используется *1.5 внутри)
    const val AMPLITUDE_THRESHOLD_MM_COORD = 1.5   // базовый порог, эффективный = 2.25 мм
    const val AMPLITUDE_THRESHOLD_MM = AMPLITUDE_THRESHOLD_MM_COORD // базовый (совместимость)
    // Коррекция частоты: учитываем почти целые волны
    const val OSCILLATION_CORRECTION = 0.30
    
    // Масштаб координационного фактора
    // АЛГОРИТМ v7: КФ = Сумма_амплитуд × (0.5 + хаотичность)
    // - Большие хаотичные движения → высокий КФ (плохая координация)
    // - Большие плавные движения → средний КФ
    // - Малые движения → низкий КФ (хорошая координация)
    const val COORDINATION_SCALE_TIME = 0.60
    const val COORDINATION_SCALE_TARGET = 0.60
    
    // Для обратной совместимости (если где-то используется старое имя)
    const val COORDINATION_SCALE = COORDINATION_SCALE_TIME
    
    // ═══════════════════════════════════════════════════════════════════
    // АВТОСТАРТ
    // ═══════════════════════════════════════════════════════════════════
    // Порог движения для автостарта (в мм)
    // Если амплитуда движения превышает этот порог - тест запускается автоматически
    // 5 мм ≈ половина зелёной зоны (зелёная = ±10 мм)
    const val AUTOSTART_THRESHOLD_MM = 5.0
}

